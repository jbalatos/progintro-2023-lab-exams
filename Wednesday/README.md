# Εύκολο θέμα
## Εκφώνηση
Δίνεται ακολουθία n χαρακτήρων (λατινικών ή και αριθμών).  Ζητάται να αλλάξετε
τα πεζά γράμματα σε κεφαλαία και ανάποδα (οι αριθμοί παραμένουν ως έχει).

## Λύση
Είναι μία απλή άσκηση επεξεργασίας κειμένου.  Από τη στιγμή που δίνεται το n δε
χρειάζεται να αναζητάτε EOF,  αλλά αυτό δε σημαίνει ότι πρέπει να αποθηκεύσετε
και τους n χαρακτήρες.

Η μετατροπή από πεζό σε κεφαλαίο και ανάποδα είναι η εξής :
Γνωρίζουμε ότι στον πίνακα ACII τα πεζά είναι συνεχόμενα και τα κεφαλαία επίσης
(όχι τα πεζά με τα κεφαλαία,  τα κεφαλαία μεταξύ τους).  Άρα το c - 'a' επιστρέφει
την θέση του πεζού γράμματος αποθηκευμένου στο c (με zero indexing).  Άρα το
c - 'a' + 'A' επιστρέφει το αντίστοιχο κεφαλαίο (όμοια c - 'A' + 'a' για την
μετατροπή κεφαλαίο -> πεζό).

> Πολυπλοκότητα : $O(n)$

# Δύσκολο θέμα
## Εκφώνηση
Δίνεται ακολουθία n μη αρνητικών ακεραίων και θετικός ακέραιος K.  Να βρείτε το
ελάχιστο μήκος υποπίνακα (διαδοχικών όρων της ακολουθίας),  το άθροισμα του
οποίου είναι τουλάχιστον K.

## Απλή λύση
Διατρέχουμε όλους τους υποπίνακες (δλδ. όλα τα ζεύγη 1 <= i <= j <= n) και
υπολογίζουμε το άθροισμά τους.  Αν είναι μεγαλύτερο ή ίσο με Κ,  αποθηκεύουμε το
μήκος σαν πιθανή απάντηση (running minimum)

> Πολυπλοκότητα : $O(n^3)$ ($O(n^2)$ υποπίνακες και $O(n)$ για τον υπολογισμό
του αθροίσματος)

> Ο κώδικας δε γράφεται λόγω της ομοιότητας με τον παρακάτω.

## Βελτίωση
Μπορούμε να υπολογίσουμε το άθροισμα των υποπινάκων σε $O(1)$ (είτε με prefix
sums είτε με σωστή προσπέλαση των υποπινάκων).

> Πολυπλοκότητα : $O(n^2)$

## Δυαδική αναζήτηση
Υπάρχει λύση με δυαδική αναζήτηση.  Δε θα παρουσιαστεί αναλυτικά.
Σύνοψη : Αναζητάς στο prefix sum array για κάθε j,  το μεγαλύτερο 1 <= i <= j
με S[i..i-1] = a[1] + a[2] + ... + a[i-2] + a[i-1] <= S[j] + K

> Πολυπλοκότητα : $O(n\log n)$

## Βέλτιστη λύση
Το πρόβλημα ανήκει στην κατηγορία 2 pointers method.  Παρακάτω περιγράφεται η
λύση.

Έστω ζεύγος (i, j) με άθροισμα s >= k και μέγιστο i για το δεδομένο j.  Το
ζεύγος (i+1, j) έχει άθροισμα s - a[i] < k (μέγιστο i),  άρα αναζητάμε το πρώτο
j' > j έτσι ώστε το (i+1, j') να έχει άθροισμα s' >= k.
Επειδή ζητάμε το πρώτο j' ή το μέγιστο i,  το μήκος είναι ελάχιστο δυνατό.

> Πολυπλοκότητα : $O(n)$
