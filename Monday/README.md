# Εύκολο θέμα 
## Εκφώνηση
Δίνεται ακολουθία n ακεραίων και ακέραιος Κ.  Nα βρεθεί πόσες φορές εμφανίζεται
ο Κ στην ακολουθία

## Λύση
Αρκεί μία προσπέλαση του πίνακα : ελέγχουμε αν το στοιχείο a[i] ισούται με το K
και,  αν ναι,  αυξάνουμε έναν μετρητή.

> Πολυπλοκότητα: $O(n)$

# Δύσκολο θέμα
## Εκφώνηση
Δίνεται ακολουθία n μη αρνητικών ακεραίων.  Nα βρεθουν 1 <= i <= j <= n τέτοια
ώστε να μεγιστοποιείται η ποσότητα : min{ a[i], a[j] } * (j - i + 1)

## Απλή λύση
Απλώς διατρέχουμε κάθε πιθανό ζεύγος (i, j) και αποθηκεύουμε την μέγιστη τιμή
του γινομένου (running maximum)

> Πολυπλοκότητα : $O(n^2)$

> Η εκφώνηση μας δίνει ότι το γινόμενο δε θα υπερβεί το $10^9$,  άρα η απάντηση
> χωράει σε μεταβλητή τύπου int.

> Το INT_MIN μπορεί να αντικατασταθεί από οποιαδήποτε τιμή μικρότερη ή ίση με το
> αποτέλεσμα,  αλλά είναι συνηθισμένη τεχνική αρχικοποίησης running maximum.
> Όμοια,  οι συναρτήσεις max,  min μπορούν να υλοποιηθούν in-place,  αλλά είναι
> πιο εύκολος και κατανοητός ο κώδικας με την χρήση τους.

## Μεσαία λύση
Μία μη-βέλτιστη,  αλλά καλύτερη από την απλή,  επιτυγχάνεται μέσω της δυαδικής
αναζήτησης.

Έστω ότι a[i] >= a[j].  Τότε η ποσότητα γίνεται a[j] * (j - i + 1),  άρα μας
συμφέρει το μικρότερο δυνατό κατάλληλο i.  Άρα ζητάμε το πρώτο 1 <= i < j τέτοιο
ώστε : a[i] >= a[j].
Κατασκευάζουμε έναν prefix max array,  δηλαδή έναν πίνακα pref μήκους n τέτοιο
ώστε : pref[i] = max{ a[k] : 1 <= k <= i }.  Ο πίνακας είναι προφανώς
ταξινομημένος σε αύξουσα σειρά (αν a[i] > pref[i-1] τότε pref[i] = a[i] > pref[i-1],
αν a[i] <= pref[i-1] τότε pref[i] = pref[i-1]).  Άρα αρκεί να αναζητήσουμε με
δυαδική αναζήτηση την πρώτη θέση στο {1..l-1} με max[i] >= a[j].
Κάνοντας το ίδιο και για την υπόθεση a[i] <= a[j],  η μέγιστη απάντηση μεταξύ
των 2 υποθέσεων είναι η απάντηση του αρχικού προβλήματος.

> Πολυπλοκότητα : $O(n\log n)$ (για κάθε θέση του πίνακα τρέχουμε 2 δυαδικές
> αναζητήσεις,  μία για κάθε υπόθεση)

> Έγραψα υλοποιήσεις της binary search για να τις δείτε αν θέλετε βοήθεια.  Δεν
> τις έγραψα με το συνηθισμένο while,  γιατί μου φαίνεται δύσκολο να βρεις αν
> σου γυρνάει την πρώτη ή τελευταία εμφάνιση στον πίνακα.  Η ορολογία που
> χρησιμοποιούμε στην δυαδική αναζήτηση είναι (για αύξουσα ταξινόμηση):
> - lower bound : πρώτη θέση όχι μικρότερη από την τιμή
> - upper bound : πρώτη θέση μεγαλύτερη από την τιμή

## Βέλτιστη λύση
Η βέλτιστη λύση είναι ένας άπληστος αλγόριθμος που απλοποιεί την απόφαση
μετακίνησης από ένα ζεύγος (i, j) στο επόμενο.

Έστω ότι για ένα ζεύγος (i, j) έχουμε βέλτιστη ποσότητα P(i, j) και έστω ότι
μένει να ελέγξουμε τα ζεύγη i <= i' < j' <= j.  Αν a[i] <= a[j],  τότε
P(i, j) = a[i] * (j - i + 1).  Αν μετακινήσουμε το j (χωρίς βλάβη της γενικότητας)
σε j-1,  τότε παίρνουμε :
P(i, j-1) = min(a[i], a[j-1]) * (j - i) <= a[i] * (j-i) < P(i, j)
Άρα μας συμφέρει μόνο να μετακινήσουμε το i σε i+1.
Όμοια αν a[i] >= a[j],  προκύπτει ότι πάντα μας συμφέρει να μετακινούμε τον
δείκτη που αντιστοιχεί στην μέγιστη τιμή από τις 2.

Αν ξεκινήσουμε την αναζήτηση ζεύγους από (i, j) = (1, n),  τότε με την παραπάνω
λογική ελέγχουμε όλα τα πιθανώς βέλτιστα ζεύγη (από ζεύγος μήκους l,  μόνο 1
μήκους l-1 συμφέρει και υπάρχει μοναδικό ζεύγος μήκους n).

> Πολυπλοκότητα : $O(n)$

> Για διευκόλυνσή σας,  μπορείτε να ορίζεται functions - macros - lambdas που
> υπολογίζουν αυτόματα την τιμή μιας ποσόστητας που χρειάζεστε συχνά.  Η απώλεια
> χρόνου είναι πολύ μικρή και δε θα επηρεάσει τη βαθμολογία σας στον grader.
